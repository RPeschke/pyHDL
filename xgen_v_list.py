import os,sys,inspect
if __name__== "__main__":
    currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
    parentdir = os.path.dirname(currentdir)
    sys.path.insert(0,parentdir) 
    from CodeGen.xgenBase import *
    from CodeGen.xgen_v_symbol import *
else:

    from .xgenBase import * 
    from .xgen_v_symbol import *
    
    
class v_list_converter(vhdl_converter_base):
    def __init__(self):
        super().__init__()
    def includes(self,obj, name,parent):
        ret  = """
library IEEE;
library UNISIM;
use IEEE.numeric_std.all;
use IEEE.std_logic_1164.all;
use UNISIM.VComponents.all;
use ieee.std_logic_unsigned.all;
        """
        if "std_logic_vector"  in obj.Internal_Type.type:
            ret +=  "  use work."+obj.type+"_pack.all;\n"

        ret += obj.Internal_Type.hdl_conversion__.includes(obj.Internal_Type,name,obj)
        return ret


    def get_packet_file_name(self, obj):
        if "std_logic_vector" not in obj.Internal_Type.type:
            return ""
        return obj.type+"_pack.vhd"

    def get_packet_file_content(self, obj):

        if "std_logic_vector" not in obj.Internal_Type.type:
            return ""

        includes = obj.hdl_conversion__.includes(obj,None,None)
        includes = make_unique_includes(includes, obj.type+"_pack")
        ret =  """ 
-- XGEN: Autogenerated File

{includes}


package {objType}_pack is 
  type {objType} is array (natural range <>) of {Internal_Type};
end {objType}_pack;

package body {objType}_pack is

end {objType}_pack;
""".format(
    objType=obj.type,
    size = obj.get_size(),
    Internal_Type=obj.Internal_Type.type,
    includes=includes
)
        return ret

    def get_architecture_header(self, obj):
        ret =""

        obj1 =obj.Internal_Type.hdl_conversion__.extract_conversion_types(obj.Internal_Type)
        
        for x in obj1:
            if x["symbol"].varSigConst == varSig.variable_t:
                continue

            ret += """  {VarSymb} {objName} : {objType}({size} - 1 downto 0)  := (others => {defaults});\n""".format(
                VarSymb=get_varSig(x["symbol"].varSigConst),
                objName=obj.get_vhdl_name(x["symbol"].Inout),
                objType=x["symbol"].hdl_conversion__.get_Name_array(x["symbol"]),
                defaults=x["symbol"].hdl_conversion__.get_default_value(x["symbol"]),
                size = obj.size
            )
        return ret

    def getHeader(self,obj, name,parent):
        return "v_list getHeader"    

    def _vhdl_slice(self,obj, sl,astParser=None):
        if issubclass(type(sl),vhdl_base0):
            sl = sl.hdl_conversion__._vhdl__getValue(sl,ReturnToObj="integer",astParser=astParser)
        
        ret = v_copy(obj.Internal_Type)
        ret.varSigConst = obj.varSigConst
        ret.vhdl_name =  obj.vhdl_name+"("+str(sl)+")"

        return ret
    def get_process_header(self,obj):
        ret =""

        obj1 =obj.Internal_Type.hdl_conversion__.extract_conversion_types(obj.Internal_Type)
        
        for x in obj1:
            if x["symbol"].varSigConst != varSig.variable_t:
                continue

            ret += """  {VarSymb} {objName} : {objType}({size} - 1 downto 0)  := (others => {defaults});\n""".format(
                VarSymb=get_varSig(x["symbol"].varSigConst),
                objName=obj.get_vhdl_name(x["symbol"].Inout),
                objType=x["symbol"].hdl_conversion__.get_Name_array(x["symbol"]),
                defaults=x["symbol"].hdl_conversion__.get_default_value(x["symbol"]),
                size = obj.size
            )
        return ret
        
  
    def _vhdl__reasign(self, obj, rhs, context=None):
        asOp = obj.hdl_conversion__.get_assiment_op(obj)
        return str(obj.vhdl_name) + asOp +  str(rhs.vhdl_name)

    def _vhdl__Pull(self,obj):
        ret = ""
        if obj.driver == None:
            return ret

        if obj.Internal_Type.__vectorPull__ == True:
            driver_name  = str(obj.driver)
            if obj.Internal_Type.__v_classType__ == v_classType_t.Master_t:
                driver_name =  str(obj.driver) +"_s2m"
            elif obj.Internal_Type.__v_classType__ == v_classType_t.Slave_t:
                driver_name = str(obj.driver) +"_m2s"

            ret += "  pull(" + str(obj) +", "+ driver_name +");\n  "
            return ret


        raise Exception("Not implemented")

    def _vhdl__push(self,obj):
        ret = ""
        if obj.driver == None:
            return ret

        if obj.Internal_Type.__vectorPush__ == True:
            driver_name  = str(obj.driver)
            if obj.Internal_Type.__v_classType__ == v_classType_t.Master_t:
                driver_name = str(obj.driver) +"_m2s"
            elif obj.Internal_Type.__v_classType__ == v_classType_t.Slave_t:
                driver_name =  str(obj.driver) +"_s2m"

            ret += "  push(" + str(obj) +", "+ driver_name +");\n  "
            return ret


        raise Exception("Not implemented")

    def length(self,obj):
        ret = v_int()
        ret.vhdl_name=str(obj)+"'length"
        return ret  
class v_list(vhdl_base):
    def __init__(self,Internal_Type,size,varSigConst=None):
        super().__init__()
        self.hdl_conversion__ = v_list_converter()
        self.Internal_Type = Internal_Type
        self.driver = None
        self.content = []
        self.Inout  = InOut_t.Internal_t
        self.__Driver__ = None
        for i in range( value(size)):
            self.content.append( v_copy(Internal_Type) )

        self.size = size
        self.varSigConst = get_value_or_default(varSigConst, getDefaultVarSig())
        self.vhdl_name = None
        self.type = self.Internal_Type.hdl_conversion__.get_type_simple(self.Internal_Type)+"_a"

    def append(self, obj):
        self.content.append(obj)
        self.size = len(self.content)

    def set_vhdl_name(self,name, Overwrite = False):
        if self.vhdl_name and self.vhdl_name != name and Overwrite == False:
            raise Exception("double Conversion to vhdl")
        else:
            self.vhdl_name = name

    def get_size(self):
        return self.size

    def __getitem__(self,sl):
        return self.content[value(sl)]

    def set_simulation_param(self,module, name,writer):
        i = 0
        for x in self.content:
            x.set_simulation_param(module+"."+name, name+"(" +str(i)+")",writer)
            i+=1

    def setInout(self,Inout):
        self.Inout = Inout

    def set_varSigConst(self, varSigConst):
        self.varSigConst = varSigConst
        self.Internal_Type.set_varSigConst(varSigConst)
        for x in self.content:
            x.set_varSigConst(varSigConst)

    def __lshift__(self, rhs):
        if len(self.content) != len(rhs.content):
            raise Exception("Differnt list size")

        for x in range(len(self.content)):
            self.content[x] << rhs.content[x]

    def _sim_set_push_pull(self, symbol):
        for x in self.content:
            x._sim_set_push_pull( symbol)


    def get_master(self):
        master_t =  self.Internal_Type.get_master() 
        ret = v_list(master_t,0,master_t.varSigConst)
        for x in self.content:
            ret.append(x.get_master() )

        ret.driver = self
        return ret


    def get_slave(self):
        master_t =  self.Internal_Type.get_master() 
        ret = v_list(master_t,0,master_t.varSigConst)
        for x in self.content:
            ret.append(x.get_master())
        
        ret.driver = self
        return ret

    def __str__(self):
        return str(self.vhdl_name)
        
    def __len__(self):
        return len(self.content)


        
    def get_vhdl_name(self,Inout=None):
        if Inout== None:
            return self.vhdl_name


        if Inout== InOut_t.input_t:
            return self.vhdl_name+"_s2m"
        
        elif Inout== InOut_t.output_t:
            return self.vhdl_name+"_m2s"
        return self.vhdl_name

    def _sim_append_update_list(self,up):
        for x in self.content:
            x._sim_append_update_list(up)

    def _issubclass_(self,test):
        if super()._issubclass_(test):
            return True
        return "v_list" == test